{"version":3,"sources":["webpack://cqSpaPageModelManager/webpack/universalModuleDefinition","webpack://cqSpaPageModelManager/webpack/bootstrap","webpack://cqSpaPageModelManager/./src/PathUtils.js","webpack://cqSpaPageModelManager/./src/Constants.js","webpack://cqSpaPageModelManager/./src/MetaProperty.js","webpack://cqSpaPageModelManager/./src/ModelManager.js","webpack://cqSpaPageModelManager/external \"clone\"","webpack://cqSpaPageModelManager/./src/EventType.js","webpack://cqSpaPageModelManager/./src/ModelClient.js","webpack://cqSpaPageModelManager/./index.js","webpack://cqSpaPageModelManager/./src/InternalConstants.js","webpack://cqSpaPageModelManager/./src/EditorClient.js","webpack://cqSpaPageModelManager/./src/ModelStore.js","webpack://cqSpaPageModelManager/./src/ModelRouter.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","CONTEXT_PATH_REGEXP","JCR_CONTENT_PATTERN","Constants","JCR_CONTENT","PathUtils","window","e","location","getCurrentPathname","matches","exec","lastIndex","path","rootPath","localPath","internalize","sanitize","url","contextPath","getContextPath","startsWith","endsWith","replace","propertyName","isBrowser","meta","document","head","querySelector","content","InternalConstants","DEFAULT_MODEL_JSON_EXTENSION","convertToModelUrl","metaModelUrl","getMetaPropertyValue","MetaProperty","PAGE_MODEL_ROOT_URL","getCurrentPageModelUrl","selectorIndex","indexOf","substr","extension","length","extensionPath","match","queue","selector","index","slice","pathname","undefined","eventName","options","dispatchEvent","CustomEvent","paths","normalize","filter","join","splashIndex","lastIndexOf","substring","RegExp","test","targetPath","targetPathChildren","makeRelative","split","rootPathChildren","delimitators","forEach","delimitator","newPaths","delim","makeAbsolute","concat","lastPath","splice","pagePath","dataPath","splitPaths","itemPath","strings","str","returnStr","TYPE_PROP","ITEMS_PROP","ITEMS_ORDER_PROP","PATH_PROP","CHILDREN_PROP","HIERARCHY_TYPE_PROP","PAGE_MODEL_ROUTE_FILTERS","PAGE_MODEL_ROUTER","_PathUtils","_EditorClient","_ModelClient","_ModelStore","adaptPagePath","modelStore","ModelManager","modelClient","Promise","resolve","reject","addSelector","addExtension","externalize","config","_this","destroy","initialModel","_modelClient","model","_listenersMap","_fetchPromises","_initPromise","metaPropertyModelUrl","currentPathname","rootModelURL","console","error","ModelClient","_editorClient","EditorClient","_modelStore","ModelStore","_checkDependencies","then","rootModelPath","data","getData","_fetchData","rootModel","initialize","modelRootPath","isPageURLRoot","childPath","hasChildOfPath","insertData","_this2","promise","fetch","_toModelPath","obj","catch","isItem","_notifyListeners","_this3","forceReload","item","_storeData","listenersForPath","listener","callback","adaptedPath","push","require","PAGE_MODEL_INIT","PAGE_MODEL_LOADED","PAGE_MODEL_UPDATE","PAGE_MODEL_ROUTE_CHANGED","apiHost","_classCallCheck","_apiHost","modelPath","err","Error","response","status","json","default","keys","DEFAULT_SLING_MODEL_SELECTOR","_modelManager","_windowListener","event","detail","msg","_updateModel","addEventListener","EventType","cmd","_clone2","siblingName","insertBefore","setData","removeData","getParentNodePath","getNodeName","log","dispatchGlobalCustomEvent","triggerPageModelLoaded","_data","removeEventListener","_pageContentDelimiter","_rootPath","arguments","parent","parentPath","answer","items","pathKey","childItem","subPath","subpath","pageDelimiter","_getStartStrings","childParentPath","trimStrings","_findItemData","newData","itemKey","localData","immutable","dataPaths","splitPageContentPaths","pageData","_getPageData","result","itemName","warn","getModelPath","getRouteFilters","isRouteExcluded","isModelRouterEnabled","dispatchRouteChanged","routeModel","ROUTER_MODES","DISABLED","CONTENT_PATH","localUrl","endPosition","routeFilters","route","modelRouterMetaType","ModelManagerSerice","pushState","history","replaceState","state","title","apply"],"mappings":"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","file":"cq-spa-page-model-manager.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cqSpaPageModelManager\"] = factory();\n\telse\n\t\troot[\"cqSpaPageModelManager\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","/*\n * ADOBE CONFIDENTIAL\n *\n * Copyright 2018 Adobe Systems Incorporated\n * All Rights Reserved.\n *\n * NOTICE:  All information contained herein is, and remains\n * the property of Adobe Systems Incorporated and its suppliers,\n * if any.  The intellectual and technical concepts contained\n * herein are proprietary to Adobe Systems Incorporated and its\n * suppliers and may be covered by U.S. and Foreign Patents,\n * patents in process, and are protected by trade secret or copyright law.\n * Dissemination of this information or reproduction of this material\n * is strictly forbidden unless prior written permission is obtained\n * from Adobe Systems Incorporated.\n */\nimport Constants from \"./Constants\";\nimport InternalConstants from \"./InternalConstants\";\nimport MetaProperty from \"./MetaProperty\";\n\n/**\n * Regexp used to extract the context path of a location.\n * The context path is extracted by assuming that the location starts with the context path followed by one of the following node names\n */\nconst CONTEXT_PATH_REGEXP = /^(.*)?(?:\\/(?:content|conf|apps|libs|etc)\\/.*)/g;\n\nconst JCR_CONTENT_PATTERN = '(.+)/' + Constants.JCR_CONTENT +'/(.+)';\n\n/**\n * Helper functions related to path manipulation.\n *\n * @namespace PathUtils\n */\nexport class PathUtils {\n\n    /**\n     * Returns if the code executes in the browser context or not by checking for the\n     * existance of the window object\n     *\n     * @returns {Boolean} the result of the check of the existance of the window object\n     */\n    static isBrowser() {\n        try {\n            return typeof window !== 'undefined';\n        }catch(e){\n            return false;\n        }\n    }\n\n    /**\n     * Returns the context path of the given location.\n     * If no location is provided, it fallbacks to the current location.\n     * @param {String} [location] - Location to be used to detect the context path from.\n     * @returns {String}\n     */\n    static getContextPath(location) {\n        location = location || this.getCurrentPathname();\n        if (!location) {\n            return \"\";\n        }\n\n        let matches = CONTEXT_PATH_REGEXP.exec(location);\n        CONTEXT_PATH_REGEXP.lastIndex = 0;\n        if (matches && matches[1]) {\n            return matches[1];\n        } else {\n            return \"\";\n        }\n    }\n\n    /**\n     * Adapts the provided path to a valid model path.\n     * Returns an empty string if the given path is equal to the root model path.\n     * This function is a utility tool that converts a provided root model path into an internal specific empty path\n     *\n     * @param {string} [path]   - raw model path\n     * @return {string} the valid model path\n     *\n     * @private\n     */\n    static adaptPagePath(path, rootPath) {\n        if (!path) {\n            return '';\n        }\n\n        if (!rootPath) {\n            return path;\n        }\n\n        const localPath = PathUtils.internalize(path);\n        const localRootModelPath = PathUtils.sanitize(rootPath);\n\n        return localPath === localRootModelPath ? '' : localPath;\n    }\n\n    /**\n     * Returns the given URL externalized by adding the optional context path\n     *\n     * @param {string} url - URL to externalize\n     * @returns {string}\n     */\n    static externalize(url) {\n        const contextPath = this.getContextPath();\n\n        if (!contextPath || url.startsWith(contextPath)) {\n            return url;\n        }\n\n        return contextPath + url;\n    }\n\n    /**\n     * Returns the given URL internalized by removing the optional context path\n     *\n     * @param {string} url - URL to internalize\n     * @returns {string}\n     */\n    static internalize(url) {\n        if (!url) {\n            return url;\n        }\n\n        const contextPath = this.getContextPath();\n\n        // Does the path starts with a node\n        if (url.startsWith(contextPath.endsWith('/') ? contextPath : contextPath + '/')) {\n            return url.replace(contextPath, \"\");\n        } else {\n            return url;\n        }\n    }\n\n    /**\n     * Returns the value of the meta property with the given key\n     *\n     * @param {string} propertyName  - name of the meta property\n     * @return {string|undefined}\n     */\n    static getMetaPropertyValue(propertyName) {\n        if (this.isBrowser()) {\n            const meta = document.head.querySelector('meta[property=\"' + propertyName + '\"]');\n            return meta && meta.content;\n        }\n    }\n\n    /**\n     * Returns a model path for the given URL\n     *\n     * @param {string} url - Raw URL for which to get a model URL\n     * @return {string|undefined}\n     */\n    static convertToModelUrl(url) {\n        return url && url.replace && url.replace(/\\.htm(l)?$/, InternalConstants.DEFAULT_MODEL_JSON_EXTENSION);\n    }\n\n    /**\n     * Returns the model URL as contained in the current page URL\n     *\n     * @return {string}\n     */\n    static getCurrentPageModelUrl() {\n        // extract the model from the pathname\n        return this.convertToModelUrl(this.getCurrentPathname());\n    }\n\n    /**\n     * Returns the URL of the page model to initialize the page model manager with.\n     * It is either derived from a meta tag property called 'cq:pagemodel_root_url' or from the given location.\n     * If no location is provided, it derives it from the current location.\n     *\n     * @param {String} [url]   - path or URL to be used to derive the page model URL from\n     * @returns {String}\n     */\n    static getModelUrl(url) {\n        // Model path extracted from the given url\n        if (url && url.replace) {\n            return this.convertToModelUrl(url);\n        }\n\n        // model path from the meta property\n        const metaModelUrl = this.getMetaPropertyValue(MetaProperty.PAGE_MODEL_ROOT_URL);\n\n        if (metaModelUrl) {\n            return metaModelUrl;\n        }\n\n        // Model URL extracted from the current page URL\n        return this.getCurrentPageModelUrl();\n    }\n\n    /**\n     * Returns the given path after sanitizing it.\n     * This function should be called on page paths before storing them in the page model,\n     * to make sure only properly formatted paths (e.g., \"/content/mypage\") are stored.\n     * @param {string} path - Path of the page to be sanitized.\n     * @return {string|undefined}\n     */\n    static sanitize(path) {\n        if (!path) {\n            return;\n        }\n\n        // Remove protocol, domain, port and keep only the path\n        path = path.replace(\n            /^[a-z]{4}:\\/{2}[a-z]{1,}:[0-9]{1,4}(\\/.*)/,\n            \"$1\"\n        );\n        // Remove possible selectors\n        let selectorIndex = path.indexOf(\".\");\n        path = selectorIndex > -1 ? path.substr(0, selectorIndex) : path;\n        // Remove possible context path\n        path = this.internalize(path);\n\n        return path;\n    }\n\n    /**\n     * Returns the given path extended with the given extension.\n     * @param {String} path - Path to be extended.\n     * @param {String} extension - Extension to be added.\n     * @returns {String}\n     */\n    static addExtension(path, extension) {\n        if (!extension || extension.length < 1) {\n            return path;\n        }\n\n        if (!extension.startsWith(\".\")) {\n            extension = \".\" + extension;\n        }\n\n        if (!path || path.length < 1 || path.indexOf(extension) > -1) {\n            return path;\n        }\n\n        let extensionPath = path;\n\n        // Groups\n        // 1. the resource\n        // 2. the selectors and the extension\n        // 3. the suffix\n        // 4. the parameters\n        let match = /^((?:[/a-zA-Z0-9:_-]*)+)(?:\\.?)([a-zA-Z0-9._-]*)(?:\\/?)([a-zA-Z0-9/._-]*)(?:\\??)([a-zA-Z0-9=&]*)$/g.exec(\n            path\n        );\n        let queue = \"\";\n\n        if (match && match.length > 2) {\n            // suffix\n            queue = match[3] ? \"/\" + match[3] : \"\";\n            // parameters\n            queue += match[4] ? \"?\" + match[4] : \"\";\n\n            extensionPath =\n                match[1] +\n                \".\" +\n                match[2].replace(/\\.htm(l)?/, extension) +\n                queue;\n        }\n\n        return extensionPath.indexOf(extension) > -1\n            ? extensionPath\n            : extensionPath + extension + queue;\n    }\n\n    /**\n     * Returns the given path extended with the given selector.\n     * @param {String} path - Path to be extended.\n     * @param {String} selector - Selector to be added.\n     * @returns {String}\n     */\n    static addSelector(path, selector) {\n        if (!selector || selector.length < 1) {\n            return path;\n        }\n\n        if (!selector.startsWith(\".\")) {\n            selector = \".\" + selector;\n        }\n\n        if (!path || path.length < 1 || path.indexOf(selector) > -1) {\n            return path;\n        }\n\n        let index = path.indexOf(\".\") || path.length;\n\n        if (index < 0) {\n            return path + selector;\n        }\n\n        return path.slice(0, index) + selector + path.slice(index, path.length);\n    }\n\n    /**\n     * Returns the current location as a string.\n     * @returns {String}\n     */\n    static getCurrentPathname() {\n        return this.isBrowser() ? window.location.pathname : undefined;\n    }\n\n    /**\n     * Dispatches a custom event on the window object, when in the browser context\n     *\n     * @param  {String} eventName - the name of the custom event\n     * @param {Object} options - the custom event options\n     */\n    static dispatchGlobalCustomEvent(eventName, options) {\n        if (this.isBrowser()) {\n            window.dispatchEvent(new CustomEvent(eventName, options));\n        }\n    }\n\n    /**\n     * Joins given path segments into a string using /\n     *\n     * @param paths\n     * @returns {string}\n     */\n    static join (paths) {\n        return paths ? this.normalize(paths.filter((path) => path).join('/')) : \"\";\n    }\n\n    /**\n     * Normalizes given path by replacing repeated / with a single one\n     *\n     * @param path\n     * @returns {string}\n     */\n    static normalize(path) {\n        if (!path) return \"\";\n        return path ? path.replace(/(\\/+)/g, '/') : \"\";\n    }\n\n    /**\n     * Returns path that starts with /\n     *\n     * @param path\n     * @returns {*}\n     */\n    static makeAbsolute(path) {\n        if (!path || (typeof path !== \"string\")) return \"\";\n        return path.startsWith('/') ? path : \"/\" + path;\n    }\n\n    /**\n     * Returns path without the leading /\n     *\n     * @param path\n     * @returns {*}\n     */\n    static makeRelative(path) {\n        if (!path || (typeof path !== \"string\")) return \"\";\n        return path.startsWith('/') ? path.slice(1) : path;\n    }\n\n    /**\n     * Returns path to the direct parent\n     *\n     * @param path\n     * @returns {*|boolean|string}\n     */\n    static getParentNodePath(path) {\n        const splashIndex = path.lastIndexOf('/') + 1;\n        return path && typeof path === 'string' && splashIndex > 0 && splashIndex < path.length && path.substring(0, splashIndex - 1);\n    }\n\n    /**\n     * Checks if given path is an JCR path\n     *\n     * @param path\n     * @returns {boolean}\n     */\n    static isItem(path) {\n        return new RegExp(JCR_CONTENT_PATTERN).test(path);\n    }\n\n    /**\n     * Returns the name of the last node of the given path\n     * @param path\n     * @returns {*|boolean|string}\n     */\n    static getNodeName(path) {\n        const splashIndex = path.lastIndexOf('/') + 1;\n        return path && typeof path === 'string' && splashIndex < path.length && path.substring(splashIndex, path.length);\n    }\n\n    /**\n     * Returns the subpath of the targetPath relative to the rootPath,\n     * or the targetPath if the rootPath is not a root of the targetPath.\n     *\n     * @param targetPath\n     * @param rootPath\n     * @returns {*}\n     */\n    static subpath(targetPath, rootPath) {\n        if (!targetPath) {\n            return \"\";\n        }\n\n        let targetPathChildren = PathUtils.makeRelative(targetPath).split('/');\n        let rootPathChildren = PathUtils.makeRelative(rootPath).split('/');\n\n        if (targetPathChildren.length < rootPathChildren.length) {\n            return targetPath;\n        }\n\n        let index;\n        for(index = 0; index < rootPathChildren.length; ++index) {\n            if (targetPathChildren[index] !== rootPathChildren[index]) {\n                break;\n            }\n        }\n\n        if (index === rootPathChildren.length) {\n            return targetPathChildren.slice(index).join(\"/\");\n        } else {\n            return targetPath;\n        }\n    }\n\n    /**\n     * Returns an array of segments of the path, split by the custom set of delimitators passed as an array.\n     *\n     * @param {string} path\n     * @param {array} delimitators\n     * @returns {*}\n     */\n    static splitByDelimitators(path, delimitators) {\n        let paths = [path];\n        delimitators.forEach((delimitator) => {\n            let newPaths = [];\n            let delim = PathUtils.normalize(PathUtils.makeAbsolute(delimitator) + \"/\");\n            paths.forEach((path) => {\n                newPaths = newPaths.concat(path.split(delim));\n                if (path.endsWith(delimitator)) {\n                    let lastPath = newPaths.splice(newPaths.length-1, 1)[0];\n                    if (lastPath !== delimitator) {\n                        newPaths = newPaths.concat(lastPath.split(PathUtils.makeAbsolute(delimitator)));\n                    }\n                }\n                newPaths = newPaths.filter((path) => path);\n            });\n            paths = newPaths;\n        });\n        return paths;\n    }\n\n    /**\n     * Returns an JCR path based on pagePath and dataPath\n     *\n     * @param pagePath  path to the page\n     * @param dataPath  path to the item on the page\n     * @returns {string}\n     */\n    static _getJCRPath(pagePath, dataPath) {\n        return pagePath + '/' + Constants.JCR_CONTENT + '/' + dataPath;\n    }\n\n    /**\n     * Returns object containing pagePath (path to a page) and, if exists, itemPath (path to the item on that page)\n     * from the passed path\n     *\n     * @param {string} path\n     * @returns {{pagePath}}\n     */\n    static splitPageContentPaths(path) {\n        if (!path && typeof path !== 'string') {\n            return;\n        }\n\n        const splitPaths = path.split('/' + Constants.JCR_CONTENT + '/');\n\n        let split = {\n            pagePath: splitPaths[0]\n        };\n\n        if (splitPaths.length > 1) {\n            split.itemPath = splitPaths[1];\n        }\n\n        return split;\n    }\n\n    /**\n     * Returns path that is no longer prefixed nor suffixed by the set of strings passed as an array\n     *\n     * @param path\n     * @param {array} strings\n     * @returns {*}\n     */\n    static trimStrings(path, strings) {\n        strings.forEach((str) => {\n            while(path.startsWith(str)) {\n                path = PathUtils.makeRelative(path.slice(str.length));\n            }\n\n            while(path.endsWith(str)) {\n                path = path.slice(0, path.length - str.length);\n                if (path.endsWith('/')) {\n                    path = path.slice(0, path.length - 1);\n                }\n            }\n        });\n        return path;\n    }\n\n    static _getStartStrings(path, strings) {\n        let returnStr = \"\";\n        strings.forEach((str) => {\n            while(path.startsWith(str)) {\n                path = PathUtils.makeRelative(path.slice(str.length));\n                returnStr = returnStr + \"/\" + str;\n            }\n        });\n        return PathUtils.makeRelative(returnStr);\n    }\n}","/*\n * ADOBE CONFIDENTIAL\n *\n * Copyright 2018 Adobe Systems Incorporated\n * All Rights Reserved.\n *\n * NOTICE:  All information contained herein is, and remains\n * the property of Adobe Systems Incorporated and its suppliers,\n * if any.  The intellectual and technical concepts contained\n * herein are proprietary to Adobe Systems Incorporated and its\n * suppliers and may be covered by U.S. and Foreign Patents,\n * patents in process, and are protected by trade secret or copyright law.\n * Dissemination of this information or reproduction of this material\n * is strictly forbidden unless prior written permission is obtained\n * from Adobe Systems Incorporated.\n */\n\n/**\n * Useful variables for interacting with CQ/AEM components\n *\n * @namespace Constants\n */\nconst Constants = {\n\n    /**\n     * Type of the item\n     *\n     * @type {string}\n     */\n    TYPE_PROP: ':type',\n\n    /**\n     * List of child items of an item\n     *\n     * @type {string}\n     */\n    ITEMS_PROP: ':items',\n\n    /**\n     * Order in which the items should be listed\n     *\n     * @type {string}\n     */\n    ITEMS_ORDER_PROP: ':itemsOrder',\n\n    /**\n     * Path of an item\n     *\n     * @type {string}\n     */\n    PATH_PROP: ':path',\n\n    /**\n     * Children of a hierarchical item\n     *\n     * @type {string}\n     */\n    CHILDREN_PROP: ':children',\n\n    /**\n     * Hierarchical type of the item\n     */\n    HIERARCHY_TYPE_PROP: ':hierarchyType',\n\n    /**\n     * JCR CONTENT Node\n     */\n    \"JCR_CONTENT\": \"jcr:content\"\n};\n\nexport default Constants;\n","/*\n * ADOBE CONFIDENTIAL\n *\n * Copyright 2018 Adobe Systems Incorporated\n * All Rights Reserved.\n *\n * NOTICE:  All information contained herein is, and remains\n * the property of Adobe Systems Incorporated and its suppliers,\n * if any.  The intellectual and technical concepts contained\n * herein are proprietary to Adobe Systems Incorporated and its\n * suppliers and may be covered by U.S. and Foreign Patents,\n * patents in process, and are protected by trade secret or copyright law.\n * Dissemination of this information or reproduction of this material\n * is strictly forbidden unless prior written permission is obtained\n * from Adobe Systems Incorporated.\n */\n\n/**\n * Names of the meta properties associated with the PageModelProvider and ModelRouter\n *\n * @type {{PAGE_MODEL_ROOT_URL: string, PAGE_MODEL_ROUTE_FILTERS: string, PAGE_MODEL_ROUTER: string}}\n */\nconst MetaProperty = {\n\n    PAGE_MODEL_ROOT_URL: 'cq:pagemodel_root_url',\n\n    PAGE_MODEL_ROUTE_FILTERS: 'cq:pagemodel_route_filters',\n\n    PAGE_MODEL_ROUTER: 'cq:pagemodel_router'\n\n};\n\nexport default MetaProperty;","/*\n * ADOBE CONFIDENTIAL\n *\n * Copyright 2018 Adobe Systems Incorporated\n * All Rights Reserved.\n *\n * NOTICE:  All information contained herein is, and remains\n * the property of Adobe Systems Incorporated and its suppliers,\n * if any.  The intellectual and technical concepts contained\n * herein are proprietary to Adobe Systems Incorporated and its\n * suppliers and may be covered by U.S. and Foreign Patents,\n * patents in process, and are protected by trade secret or copyright law.\n * Dissemination of this information or reproduction of this material\n * is strictly forbidden unless prior written permission is obtained\n * from Adobe Systems Incorporated.\n */\nimport { PathUtils } from \"./PathUtils\";\nimport Constants from \"./Constants\";\nimport MetaProperty from \"./MetaProperty\";\nimport { EditorClient } from \"./EditorClient\";\nimport { ModelClient } from \"./ModelClient\";\nimport { ModelStore } from \"./ModelStore\";\n\n/**\n * Does the provided model object contains an entry for the given child path\n *\n * @param {{}} model            - model to be evaluated\n * @param {string} childPath    - path of the child\n * @return {*}\n *\n * @private\n */\nfunction hasChildOfPath(model, childPath) {\n    return !!(model && childPath && model[Constants.CHILDREN_PROP] && model[Constants.CHILDREN_PROP][PathUtils.sanitize(childPath)]);\n}\n\n/**\n * Does the provided page path correspond to the model root path\n *\n * @param {string} pagePath         - path of the page model\n * @param {string} modelRootPath    - current model root path\n * @return {boolean}\n *\n * @private\n */\nfunction isPageURLRoot(pagePath, modelRootPath) {\n    return !pagePath || !modelRootPath || PathUtils.sanitize(pagePath) === PathUtils.sanitize(modelRootPath);\n}\n\n/**\n * Adapts the provided path to a valid model path.\n * Returns an empty string if the given path is equal to the root model path.\n * This function is a utility tool that converts a provided root model path into an internal specific empty path\n *\n * @param {string} [path]   - raw model path\n * @return {string} the valid model path\n *\n * @private\n */\nfunction adaptPagePath(path) {\n    if (!path) {\n        return '';\n    }\n\n    const localPath = PathUtils.internalize(path);\n\n    if (!this.modelStore || !this.modelStore.rootPath) {\n        return localPath;\n    }\n\n    const localRootModelPath = PathUtils.sanitize(this.modelStore.rootPath);\n\n    return localPath === localRootModelPath ? '' : localPath;\n}\n\n/**\n * The ModelManager gathers all the components implicated in managing the model data\n */\nclass ModelManager {\n\n    /**\n     * Configuration object for the getData function\n     *\n     * @typedef {{}} GetDataConfig\n     * @property {string} path             - Path of the data model\n     * @property {boolean} forceReload     - Should the data model be reloaded\n     */\n\n    /**\n     * Configuration object for the Initialization function\n     *\n     * @typedef {{}} InitializationConfig\n     * @property {string} [path]                   - Path of the data model\n     * @property {{}} [model]                      - Model structure to initialize the page model manager with\n     * @property {ModelClient} [modelClient]       - Model client\n     */\n\n    get modelClient() {\n        return this._modelClient;\n    }\n\n    get modelStore() {\n        return this._modelStore;\n    }\n\n    /**\n     * Verifies the integrity of the provided dependencies\n     *\n     * @return {Promise}\n     * @private\n     */\n    _checkDependencies() {\n        if (!this.modelClient) {\n            return Promise.reject(\"No ModelClient registered\");\n        }\n\n        if (!this.modelStore) {\n            return Promise.reject(\"No ModelManager registered\");\n        }\n\n        return Promise.resolve();\n    }\n\n    /**\n     * Transforms the given path into a model URL\n     *\n     * @param path\n     * @return {*}\n     * @private\n     */\n    _toModelPath(path) {\n        let url = PathUtils.addSelector(path, 'model');\n        url = PathUtils.addExtension(url, 'json');\n        url = PathUtils.externalize(url);\n\n        return PathUtils.makeAbsolute(url);\n    }\n\n    /**\n     * Initializes the ModelManager using the given path to resolve a data model.\n     * If no path is provided, fallbacks are applied in the following order:\n     *\n     * - meta property: cq:pagemodel_root_url\n     * - current pathname of the browser\n     *\n     * Once the initial model is loaded and if the data model doesn't contain the path of the current pathname, the library attempts to fetch a fragment of model.\n     *\n     * @param {string|InitializationConfig} [config]                - Path to the data model or configuration object\n     * @return {Promise}\n     */\n    initialize(config) {\n        this.destroy();\n        let path;\n        let initialModel;\n\n        if (!config || typeof config === 'string') {\n            path = config;\n        } else if (config) {\n            path = config.path;\n            this._modelClient = config.modelClient;\n            initialModel = config.model;\n        }\n\n        this._listenersMap = {};\n        this._fetchPromises = {};\n        this._initPromise = null;\n\n        const metaPropertyModelUrl = PathUtils.internalize(PathUtils.getMetaPropertyValue(MetaProperty.PAGE_MODEL_ROOT_URL));\n        const currentPathname = PathUtils.sanitize(PathUtils.getCurrentPathname());\n        // Fetch the app root model\n        // 1. consider the provided page path\n        // 2. consider the meta property value\n        // 3. fallback to the model path contained in the URL\n        const rootModelURL = path || metaPropertyModelUrl || currentPathname;\n\n        if (!rootModelURL) {\n            console.error('ModelManager.js', 'Cannot initialize without an URL to fetch the root model');\n        }\n\n        if (!this._modelClient) {\n            this._modelClient = new ModelClient();\n        }\n\n        this._editorClient = new EditorClient(this);\n        this._modelStore = new ModelStore(rootModelURL, initialModel);\n\n        this._initPromise = this._checkDependencies().then(() => {\n            const rootModelPath = PathUtils.sanitize(rootModelURL);\n            let data = this.modelStore.getData(rootModelPath);\n\n            if (data) {\n                return Promise.resolve(data);\n            } else {\n                return this._fetchData(rootModelURL).then((rootModel) => {\n                    this.modelStore.initialize(rootModelPath, rootModel);\n                    // Append the child page if the page model doesn't correspond to the URL of the root model\n                    // and if the model root path doesn't already contain the child model (asynchronous page load)\n                    if (!isPageURLRoot(currentPathname, metaPropertyModelUrl) && !hasChildOfPath(rootModel, currentPathname)) {\n                        return this._fetchData(currentPathname).then((model) => {\n                            this.modelStore.insertData(PathUtils.sanitize(currentPathname), model);\n\n                            return this.modelStore.getData();\n                        });\n                    } else {\n                        return this.modelStore.getData();\n                    }\n                });\n            }\n        });\n\n        return this._initPromise;\n    }\n\n    /**\n     * Fetches a model for the given path\n     *\n     * @param {string} path - Model path\n     * @return {Promise}\n     * @private\n     */\n    _fetchData(path) {\n        if (this._fetchPromises.hasOwnProperty(path)) {\n            return this._fetchPromises[path];\n        }\n\n        let promise = this.modelClient.fetch(this._toModelPath(path));\n\n        this._fetchPromises[path] = promise;\n\n        promise.then((obj) => {\n            delete this._fetchPromises[path];\n            return obj;\n        }).catch((error) => {\n            delete this._fetchPromises[path];\n            return error;\n        });\n\n        return promise;\n    }\n\n    _storeData(path, data) {\n        const isItem = PathUtils.isItem(path);\n\n        this.modelStore.insertData(path, data);\n\n        // If the path correspond to an item notify either the parent item\n        // Otherwise notify the app root\n        this._notifyListeners(path);\n\n        if (!isItem) {\n            // As we are expecting a page, we notify the root\n            this._notifyListeners('');\n        }\n\n        return data;\n    }\n\n    /**\n     * Returns the path of the data model root\n     *\n     * @return {string}\n     */\n    get rootPath() {\n        return this.modelStore.rootPath;\n    }\n\n    /**\n     * Returns the model for the given configuration\n     * @param {string|GetDataConfig} [config]     - Either the path of the data model or a configuration object. If no parameter is provided the complete model is returned\n     * @return {Promise}\n     */\n    getData(config) {\n        let path;\n        let forceReload = false;\n\n        if (typeof config === 'string') {\n            path = config;\n        } else if (config) {\n            path = config.path;\n            forceReload = config.forceReload;\n        }\n\n        let initPromise = this._initPromise || Promise.resolve();\n\n        return initPromise.then(() => this._checkDependencies())\n            .then(() => {\n                if (!forceReload) {\n                    let item = this.modelStore.getData(path);\n\n                    if (item) {\n                        return Promise.resolve(item);\n                    }\n                }\n\n                // We are not having any items\n                // We want to reload the item\n                return this._fetchData(path).then((data) => this._storeData(path, data));\n            });\n    }\n\n    /**\n     * Notifies the listeners for a given path\n     *\n     * @param {string} path - Path of the data model\n     * @private\n     */\n    _notifyListeners(path) {\n        path = PathUtils.adaptPagePath.call(this, path);\n        let listenersForPath = this._listenersMap[path];\n\n        if (!listenersForPath) {\n            return;\n        }\n\n        if (listenersForPath.length) {\n            listenersForPath.forEach((listener) => {\n                try {\n                    listener();\n                } catch (e) {\n                    console.error('Error in listener ' + listenersForPath + ' at path ' + path + ' : ' + e);\n                }\n            });\n        }\n    }\n\n\n    /**\n     * Add the given callback as a listener for changes at the given path.\n     *\n     * @param {String}  [path]  Absolute path of the resource (e.g., \"/content/mypage\"). If not provided, the root page path is used.\n     * @param {String}  [callback]  Function to be executed listening to changes at given path\n     */\n    addListener(path, callback) {\n        if (!path && typeof path !== 'string') {\n            return;\n        }\n\n        let adaptedPath = adaptPagePath.call(this, path);\n\n        this._listenersMap[adaptedPath] = this._listenersMap[path] || [];\n        this._listenersMap[adaptedPath].push(callback);\n    }\n\n    /**\n     * Remove the callback listener from the given path path.\n     *\n     * @param {String}  [path] Absolute path of the resource (e.g., \"/content/mypage\"). If not provided, the root page path is used.\n     * @param {String}  [callback]  Listener function to be removed.\n     */\n    removeListener(path, callback) {\n        if (!path) {\n            return;\n        }\n        let adaptedPath = adaptPagePath.call(this, path);\n\n        let listenersForPath = this._listenersMap[adaptedPath];\n        if (listenersForPath) {\n            let index = listenersForPath.indexOf(callback);\n            if (index !== -1) {\n                listenersForPath.splice(index, 1);\n            }\n        }\n    }\n\n    /**\n     * @private\n     */\n    destroy() {\n        this._fetchPromises = null;\n        delete this._fetchPromises;\n        this._listenersMap = null;\n        delete this._listenersMap;\n\n        if (this.modelClient && this.modelClient.destroy) {\n            this.modelClient.destroy();\n        }\n\n        if (this.modelStore && this.modelStore.destroy) {\n            this.modelStore.destroy();\n        }\n\n        if (this._editorClient && this._editorClient.destroy) {\n            this._editorClient.destroy();\n        }\n    }\n}\n\nexport default new ModelManager();","module.exports = require(\"clone\");","/*\n * ADOBE CONFIDENTIAL\n *\n * Copyright 2018 Adobe Systems Incorporated\n * All Rights Reserved.\n *\n * NOTICE:  All information contained herein is, and remains\n * the property of Adobe Systems Incorporated and its suppliers,\n * if any.  The intellectual and technical concepts contained\n * herein are proprietary to Adobe Systems Incorporated and its\n * suppliers and may be covered by U.S. and Foreign Patents,\n * patents in process, and are protected by trade secret or copyright law.\n * Dissemination of this information or reproduction of this material\n * is strictly forbidden unless prior written permission is obtained\n * from Adobe Systems Incorporated.\n */\n\n/**\n * Type of events triggered or listened by the PageModelManager and ModelRouter\n *\n * @type {{PAGE_MODEL_INIT: string, PAGE_MODEL_LOADED: string, PAGE_MODEL_UPDATE: string, PAGE_MODEL_ROUTE_CHANGED: string}}\n */\nconst EventType = {\n\n    /**\n     * Event which indicates that the PageModelManager has been initialized\n     */\n    PAGE_MODEL_INIT: 'cq-pagemodel-init',\n\n    /**\n     * Event which indicates that the PageModelManager has loaded new content\n     */\n    PAGE_MODEL_LOADED: 'cq-pagemodel-loaded',\n\n    /**\n     * Event that indicates a request to update the page model\n     */\n    PAGE_MODEL_UPDATE: 'cq-pagemodel-update',\n\n    /**\n     * Event which indicates that ModelRouter has identified that model route has changed\n     */\n    PAGE_MODEL_ROUTE_CHANGED: 'cq-pagemodel-route-changed'\n};\n\nexport default EventType;","/*\n * ADOBE CONFIDENTIAL\n *\n * Copyright 2018 Adobe Systems Incorporated\n * All Rights Reserved.\n *\n * NOTICE:  All information contained herein is, and remains\n * the property of Adobe Systems Incorporated and its suppliers,\n * if any.  The intellectual and technical concepts contained\n * herein are proprietary to Adobe Systems Incorporated and its\n * suppliers and may be covered by U.S. and Foreign Patents,\n * patents in process, and are protected by trade secret or copyright law.\n * Dissemination of this information or reproduction of this material\n * is strictly forbidden unless prior written permission is obtained\n * from Adobe Systems Incorporated.\n */\n\nexport class ModelClient {\n\n    /**\n     * @constructor\n     * @param {string} [apiHost] - Http host of the API\n     */\n    constructor(apiHost) {\n        this._apiHost = apiHost || '';\n        this._fetchPromises = {};\n    }\n\n    /**\n     * Fetches a model using the given a resource path\n     *\n     * @param {string} modelPath - Absolute path to the model.\n     * @return {*}\n     */\n    fetch(modelPath) {\n        if (!modelPath) {\n            let err = 'Fetching model rejected for path: ' + modelPath;\n            return Promise.reject(new Error(err));\n        }\n\n        // Either the API host has been provided or we make an absolute request relative to the current host\n        let url = `${this._apiHost}${modelPath}`;\n\n        return fetch(url).then(function(response) {\n            if (response.status >= 200 && response.status < 300) {\n                return response.json();\n            }\n\n            throw { response: response };\n        }).catch((error) => {\n            return Promise.reject(error);\n        });\n    }\n\n    /**\n     * Destroys the internal references to avoid memory leaks\n     */\n    destroy() {\n        this._apiHost = null;\n        this._fetchPromises = null;\n    }\n}","/*\n * ADOBE CONFIDENTIAL\n *\n * Copyright 2018 Adobe Systems Incorporated\n * All Rights Reserved.\n *\n * NOTICE:  All information contained herein is, and remains\n * the property of Adobe Systems Incorporated and its suppliers,\n * if any.  The intellectual and technical concepts contained\n * herein are proprietary to Adobe Systems Incorporated and its\n * suppliers and may be covered by U.S. and Foreign Patents,\n * patents in process, and are protected by trade secret or copyright law.\n * Dissemination of this information or reproduction of this material\n * is strictly forbidden unless prior written permission is obtained\n * from Adobe Systems Incorporated.\n */\n\nrequire('./src/ModelRouter');\n\nexport { default as ModelManager } from \"./src/ModelManager\";\nexport * from \"./src/ModelClient\";\nexport * from \"./src/PathUtils\";\nexport { default as Constants } from \"./src/Constants\";","/*\n * ADOBE CONFIDENTIAL\n *\n * Copyright 2018 Adobe Systems Incorporated\n * All Rights Reserved.\n *\n * NOTICE:  All information contained herein is, and remains\n * the property of Adobe Systems Incorporated and its suppliers,\n * if any.  The intellectual and technical concepts contained\n * herein are proprietary to Adobe Systems Incorporated and its\n * suppliers and may be covered by U.S. and Foreign Patents,\n * patents in process, and are protected by trade secret or copyright law.\n * Dissemination of this information or reproduction of this material\n * is strictly forbidden unless prior written permission is obtained\n * from Adobe Systems Incorporated.\n */\n\nconst DEFAULT_SLING_MODEL_SELECTOR = 'model';\n\nconst InternalConstants = {\n\n    DEFAULT_SLING_MODEL_SELECTOR: DEFAULT_SLING_MODEL_SELECTOR,\n\n    DEFAULT_MODEL_JSON_EXTENSION: '.' + DEFAULT_SLING_MODEL_SELECTOR + '.json'\n};\n\nexport default InternalConstants;","/*\n * ADOBE CONFIDENTIAL\n *\n * Copyright 2018 Adobe Systems Incorporated\n * All Rights Reserved.\n *\n * NOTICE:  All information contained herein is, and remains\n * the property of Adobe Systems Incorporated and its suppliers,\n * if any.  The intellectual and technical concepts contained\n * herein are proprietary to Adobe Systems Incorporated and its\n * suppliers and may be covered by U.S. and Foreign Patents,\n * patents in process, and are protected by trade secret or copyright law.\n * Dissemination of this information or reproduction of this material\n * is strictly forbidden unless prior written permission is obtained\n * from Adobe Systems Incorporated.\n */\nimport { PathUtils } from \"./PathUtils\";\nimport clone from 'clone';\nimport EventType from \"./EventType\";\n\n/**\n * Broadcast an event to indicate the page model has been loaded\n *\n * @param {{}} model - model item to be added to the broadcast payload\n * @fires cq-pagemodel-loaded\n */\nfunction triggerPageModelLoaded(model) {\n    // Deep copy to protect the internal state of the page mode\n    PathUtils.dispatchGlobalCustomEvent(EventType.PAGE_MODEL_LOADED, {\n        detail: {\n            model: clone(model)\n        }\n    });\n}\n\n/**\n * The EditorClient is responsible for the interactions with the Page Editor.\n */\nexport class EditorClient {\n\n    constructor(ModelManager) {\n        this._modelManager = ModelManager;\n\n        this._windowListener = (event) => {\n            if (!event || !event.detail || !event.detail.msg) {\n                console.error('EditorService.js', 'No message passed to cq-pagemodel-update', event);\n                return;\n            }\n\n            this._updateModel(event.detail.msg);\n        };\n\n        if (PathUtils.isBrowser()) {\n            window.addEventListener(EventType.PAGE_MODEL_UPDATE, this._windowListener);\n        }\n    }\n\n    /**\n     * Updates the page model with the given data\n     *\n     * @param {Object} msg - Object containing the data to update the page model\n     * @property {String} msg.dataPath - Relative data path in the PageModel which needs to be updated\n     * @property {String} msg.pagePath - Absolute page path corresponding to the page in the PageModel which needs to be updated\n     * @param {String} msg.cmd - Command Action requested via Editable on the content Node\n     * @param {Object} msg.data - Data that needs to be updated in the PageModel at {path}\n     *\n     * @fires cq-pagemodel-loaded\n     *\n     * @private\n     */\n    _updateModel(msg) {\n        if (!msg || !msg.cmd || !msg.path) {\n            console.error('PageModelManager.js', 'Not enough data received to update the page model');\n            return;\n        }\n        // Path in the PageModel which needs to be updated\n        let path = msg.path;\n        // Command Action requested via Editable on the content Node\n        let cmd = msg.cmd;\n        // Data that needs to be updated in the page model at the given path\n        let data = clone(msg.data);\n\n        let siblingName;\n        let itemPath;\n        let insertBefore;\n\n        switch(cmd) {\n            case 'replace':\n                this._modelManager.modelStore.setData(path, data);\n                this._modelManager._notifyListeners(path);\n                break;\n\n            case 'delete':\n                this._modelManager.modelStore.removeData(path);\n                this._modelManager._notifyListeners(PathUtils.getParentNodePath(path));\n                break;\n\n            case 'insertBefore':\n                insertBefore = true;\n                // No break as we want both insert command to be treated the same way\n                // eslint-disable-next-line no-fallthrough\n            case 'insertAfter':\n                // The logic relative to the item path and sibling between the editor and the ModelManager is reversed\n                // Adapting the command to the ModelManager API\n                siblingName = PathUtils.getNodeName(path);\n                itemPath = PathUtils.getParentNodePath(path) + \"/\" + data.key;\n                this._modelManager._modelStore.insertData(itemPath, data.value, siblingName, insertBefore);\n                this._modelManager._notifyListeners(PathUtils.getParentNodePath(path));\n\n                break;\n\n            default:\n                // \"replaceContent\" command not supported\n                // \"moveBefore\", \"moveAfter\" commands not supported.\n                // As instead, we are replacing source and destination parents because they can contain data about the item we want to relocate\n                console.log('EditorClient', 'unsupported command:', cmd);\n        }\n\n        triggerPageModelLoaded(this._modelManager.modelStore._data);\n    }\n\n    /**\n     * @private\n     */\n    destroy() {\n        this._modelManager = null;\n        delete this._modelManager;\n\n        if (PathUtils.isBrowser()) {\n            window.removeEventListener(EventType.PAGE_MODEL_UPDATE, this._windowListener);\n        }\n    }\n}","/*\n * ADOBE CONFIDENTIAL\n *\n * Copyright 2018 Adobe Systems Incorporated\n * All Rights Reserved.\n *\n * NOTICE:  All information contained herein is, and remains\n * the property of Adobe Systems Incorporated and its suppliers,\n * if any.  The intellectual and technical concepts contained\n * herein are proprietary to Adobe Systems Incorporated and its\n * suppliers and may be covered by U.S. and Foreign Patents,\n * patents in process, and are protected by trade secret or copyright law.\n * Dissemination of this information or reproduction of this material\n * is strictly forbidden unless prior written permission is obtained\n * from Adobe Systems Incorporated.\n */\nimport clone from 'clone';\nimport Constants from \"./Constants\";\nimport { PathUtils } from \"./PathUtils\";\n\n/**\n * The ModelStore is in charge of providing access to the data model. It provides the CRUD operations over the model.\n * To protect the integrity of the data it initially returns immutable data. If needed, you can request a mutable object.\n */\nexport class ModelStore {\n\n    /**\n     * Item wrapper containing information about the item parent\n     *\n     * @typedef {Object} ItemWrapper\n     * @property {string} [key]             - Name of the item\n     * @property {{}} [data]                - Item data\n     * @property {{}} [parent]                - Parent item\n     * @property {string} [parentPath]        - Path of the parent item\n     */\n\n    /**\n     * @param {string} [rootPath]     - Root path of the model\n     * @param {{}} [data]             - Initial model\n     */\n    constructor(rootPath, data) {\n        this.initialize(rootPath, data);\n        this._pageContentDelimiter = [Constants.JCR_CONTENT];\n    }\n\n    /**\n     * Initializes the the ModelManager\n     *\n     * @param {string} rootPath     - Root path of the model\n     * @param {{}} data             - Initial model\n     */\n    initialize(rootPath, data) {\n        if (data) {\n            this._data = data;\n        }\n\n        this._rootPath = rootPath;\n    }\n\n    /**\n     * Returns the current root path\n     *\n     * @return {string}\n     */\n    get rootPath() {\n        return this._rootPath;\n    }\n\n    /**\n     *\n     * @param {string} pagePath - Path of the page\n     *\n     * @return {{}|undefined} - Data of the page\n     * @private\n     */\n    _getPageData(pagePath) {\n        if (!this._data) {\n            return;\n        }\n\n        if ('' === pagePath || pagePath === this._data[Constants.PATH_PROP] || pagePath === this.rootPath) {\n            return this._data;\n        }\n\n        return  this._data[Constants.CHILDREN_PROP] && this._data[Constants.CHILDREN_PROP][pagePath];\n    }\n\n    /**\n     * Retrieves the item and eventually returns the data wrapped with the parent information\n     *\n     * @param {string} path                 - Path of the item\n     * @param {{}} [data=_data]             - Data to be explored\n     * @param {{}} [parent]                 - Parent data\n     * @param {string} [parentPath='']      - Path of the parent data\n     * @return {ItemWrapper}\n     * @private\n     */\n    _findItemData(path, data = this._data, parent, parentPath = '') {\n        let answer = {\n            parent: parent,\n            parentPath: parentPath\n        };\n\n        let items = data[Constants.ITEMS_PROP];\n\n        if (!items) {\n            return answer;\n        }\n\n        for (let pathKey in items) {\n            if (!items.hasOwnProperty(pathKey)) {\n                continue;\n            }\n\n            let childItem = items[pathKey];\n\n            // Direct child. We reached the leaf\n            if (pathKey === path) {\n                answer.data = items[pathKey];\n                answer.key = pathKey;\n                return answer;\n            } else {\n                // Continue traversing\n                let subPath = PathUtils.subpath(path, pathKey);\n                let pageDelimiter = PathUtils._getStartStrings(subPath, this._pageContentDelimiter);\n                let childParentPath = PathUtils.join([parentPath, pathKey, pageDelimiter]);\n                subPath = PathUtils.trimStrings(subPath, this._pageContentDelimiter);\n\n                if (subPath !== path) {\n                    childItem = this._findItemData(subPath, childItem, childItem, childParentPath);\n\n                    if (childItem) {\n                        return childItem;\n                    }\n                }\n            }\n        }\n\n        return answer;\n    }\n\n    /**\n     * Replaces the data in the given location\n     *\n     * @param {string} path     - Path of the data\n     * @param {{}} newData      - New data to be set\n     */\n    setData(path, newData) {\n        let itemKey = PathUtils.getNodeName(path);\n        let data = this.getData(PathUtils.getParentNodePath(path), false);\n\n        if (data && data[Constants.ITEMS_PROP]) {\n            let localData = clone(newData);\n            data[Constants.ITEMS_PROP][itemKey] = localData.value;\n        }\n    }\n\n    /**\n     * Returns the data for the given path. If no path is provided, it returns the whole data\n     *\n     * @param {string} [path]                   - Path to the data\n     * @param {boolean} [immutable=true]        - Should the returned data be a clone\n     * @return {*}\n     */\n    getData(path, immutable = true) {\n        if (!path && typeof path !== 'string') {\n            return immutable ? clone(this._data) : this._data;\n        }\n\n        // Request for the root path\n        // Returns the full data\n        if (path === this._rootPath) {\n            return immutable? clone(this._data) : this._data;\n        }\n\n        const dataPaths = PathUtils.splitPageContentPaths(path);\n\n        let pageData = this._getPageData(dataPaths.pagePath);\n\n        // If there is no page\n        // or if we are getting the data of a page\n        // return the page data\n        if (!pageData || !dataPaths.itemPath) {\n            return immutable? clone(pageData) : pageData;\n        }\n\n        let result = this._findItemData(dataPaths.itemPath, pageData);\n\n        if (result) {\n            return immutable ? clone(result.data) : result.data;\n        }\n    }\n\n    /**\n     * Insert the provided data at the location of the given path. If no sibling name is provided the data is added at the end of the list\n     *\n     * @param {string} path                     - Path to the data\n     * @param {{}} data                         - Data to be inserted\n     * @param {string} [siblingName]            - Name of the item before or after which to add the data\n     * @param {boolean} [insertBefore=false]    - Should the data be inserted before the sibling\n     */\n    insertData(path, data, siblingName, insertBefore = false) {\n        data = clone(data);\n        // We need to find the parent\n        if (!path) {\n            console.warn(\"No path provided for data:\", data);\n            return;\n        }\n\n        const isItem = PathUtils.isItem(path);\n\n        if (!isItem && this._data[Constants.CHILDREN_PROP]) {\n            // Page data\n            this._data[Constants.CHILDREN_PROP][path] = data;\n            return;\n        }\n\n        // Item data\n        const dataPaths = PathUtils.splitPageContentPaths(path);\n        let pageData = this._getPageData(dataPaths.pagePath);\n        let result = this._findItemData(dataPaths.itemPath, pageData);\n        let parent = result.parent || pageData || this._data;\n        let itemName = PathUtils.getNodeName(dataPaths.itemPath);\n\n        if (parent && parent.hasOwnProperty(Constants.ITEMS_PROP)) {\n            parent[Constants.ITEMS_PROP][itemName] = data;\n\n            if (parent.hasOwnProperty(Constants.ITEMS_ORDER_PROP)) {\n                let index = parent[Constants.ITEMS_ORDER_PROP].indexOf(siblingName);\n\n                if (index > -1) {\n                    parent[Constants.ITEMS_ORDER_PROP].splice(insertBefore ? index : index + 1, 0, itemName);\n                } else {\n                    parent[Constants.ITEMS_ORDER_PROP].push(itemName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Removes the data located at the provided location\n     *\n     * @param {string} path         - Path of the data\n     * @return {string|undefined}   - Path to the parent item initially containing the removed data\n     */\n    removeData(path) {\n        if (!path) {\n            return;\n        }\n\n        const isItem = PathUtils.isItem(path);\n\n        if (!isItem && this._data[Constants.CHILDREN_PROP]) {\n            // Page data\n            delete this._data[Constants.CHILDREN_PROP][path];\n            return;\n        }\n\n        // Item data\n        const dataPaths = PathUtils.splitPageContentPaths(path);\n        let pageData = this._getPageData(dataPaths.pagePath);\n        let result = this._findItemData(dataPaths.itemPath, pageData);\n\n        if (result.data) {\n            if (result && result.parent && result.parent.hasOwnProperty(Constants.ITEMS_PROP)) {\n                let { parent } = result;\n                let itemName = PathUtils.getNodeName(dataPaths.itemPath);\n\n                delete parent[Constants.ITEMS_PROP][itemName];\n                delete result.data;\n                delete result.parent;\n\n                if (parent.hasOwnProperty(Constants.ITEMS_ORDER_PROP)) {\n                    let index = parent[Constants.ITEMS_ORDER_PROP].indexOf(itemName);\n                    parent[Constants.ITEMS_ORDER_PROP].splice(index, 1);\n                }\n\n                return result.parentPath;\n            }\n        } else {\n            console.warn(`Item for path ${path} was not found! Nothing to remove then.`);\n        }\n    }\n\n    /**\n     * @private\n     */\n    destroy() {\n        this._data = null;\n        this._rootPath = null;\n        this._pageContentDelimiter = null;\n\n        delete this._data;\n        delete this._rootPath;\n        delete this._pageContentDelimiter;\n    }\n}","/*\n * ADOBE CONFIDENTIAL\n *\n * Copyright 2018 Adobe Systems Incorporated\n * All Rights Reserved.\n *\n * NOTICE:  All information contained herein is, and remains\n * the property of Adobe Systems Incorporated and its suppliers,\n * if any.  The intellectual and technical concepts contained\n * herein are proprietary to Adobe Systems Incorporated and its\n * suppliers and may be covered by U.S. and Foreign Patents,\n * patents in process, and are protected by trade secret or copyright law.\n * Dissemination of this information or reproduction of this material\n * is strictly forbidden unless prior written permission is obtained\n * from Adobe Systems Incorporated.\n */\nimport EventType from './EventType';\nimport { PathUtils } from \"./PathUtils\";\nimport MetaProperty from \"./MetaProperty\";\nimport ModelManagerSerice from \"./ModelManager\";\n\n/**\n * Triggered by the ModelRouter when the route has changed.\n *\n * @event cq-pagemodel-route-changed\n * @type {Object}\n * @property {Object} detail\n * @property {Object} detail.model - The page model object corresponding to the new route\n */\n\n/**\n * <p>The ModelRouter listens for HTML5 History API <i>popstate</i> events and calls {@link PageModelManager#getData()} with the model path it extracted from the URL.</p>\n *\n * <h2>Configuration</h2>\n *\n * <p>The Model Router can be configured using meta properties located in the head section of the document.</p>\n *\n * <h3>Meta properties</h3>\n * <ul>\n *     <li>cq:page_model_router - default=undefined, options=disable</li>\n *     <li>cq:page_model_route_filters - default=undefined, options=RegExp<></li>\n * </ul>\n *\n * <h3>Defaults</h3>\n * <ul>\n *     <li>The ModelRouter is enabled and uses the <i>History</i> API to extract the model path from the current content path</li>\n * </ul>\n *\n * <h3>Examples and Usages</h3>\n *\n * <h4>Disables the page model router</h4>\n * <pre>\n *     <code>e.g. &lt;meta property=\"cq:page_model_router\" content=\"disable\"\\&gt;</code>\n * </pre>\n *\n * <h4>Filters paths from the model routing with the given patterns</h4>\n * <pre>\n *     <code>e.g. &lt;meta property=\"cq:page_model_route_filters\" content=\"route/not/found,^(.*)(?:exclude/path)(.*)\"\\&gt;</code>\n * </pre>\n *\n * @module ModelRouter\n */\n\n/**\n * Modes in which the Model Router operates\n *\n * @type {{DISABLED: string, CONTENT_PATH: string}}\n */\nexport const ROUTER_MODES = {\n\n    /**\n     * Flag that indicates that the model router should be disabled\n     *\n     * @type {string}\n     */\n    DISABLED: 'disabled',\n\n    /**\n     * Flag that indicates that the model router should extract the model path from the content path section of the URL\n     *\n     * @type {string}\n     */\n    CONTENT_PATH: 'path'\n};\n\n/**\n * Returns the model path. If no URL is provided the current window URL is used\n *\n * @param {string} [url]    - url from which to extract the model path\n *\n * @return {string}\n */\nexport function getModelPath(url) {\n    let localUrl;\n\n    localUrl = url || window.location.pathname;\n\n    // The default value model path comes as the the content path\n    let endPosition = localUrl.indexOf('.');\n\n    if (endPosition < 0) {\n        endPosition = localUrl.length;\n    }\n\n    return localUrl.substr(0, endPosition);\n}\n\n/**\n * Returns the list of provided route filters\n *\n * @returns {string[]}\n *\n * @private\n */\nexport function getRouteFilters() {\n    let routeFilters = PathUtils.getMetaPropertyValue(MetaProperty.PAGE_MODEL_ROUTE_FILTERS);\n    return routeFilters ? routeFilters.split(',') : [];\n}\n\n/**\n * Should the route be excluded\n *\n * @param route\n * @returns {boolean}\n *\n * @private\n */\nexport function isRouteExcluded(route) {\n    const routeFilters = getRouteFilters();\n\n    for (let i = 0, length = routeFilters.length; i < length; i++) {\n        if (new RegExp(routeFilters[i]).test(route)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Is the model router enabled. Enabled by default\n * @returns {boolean}\n *\n * @private\n */\nexport function isModelRouterEnabled() {\n    if (!PathUtils.isBrowser()) {\n        return false;\n    }\n    const modelRouterMetaType = PathUtils.getMetaPropertyValue(MetaProperty.PAGE_MODEL_ROUTER);\n    // Enable the the page model routing by default\n    return !modelRouterMetaType || ROUTER_MODES.DISABLED !== modelRouterMetaType;\n}\n\n/**\n * Fetches the model from the PageModelManager and then dispatches it\n *\n * @fires cq-pagemodel-route-changed\n *\n * @param {string} [path]   - path of the model to be dispatched\n *\n * @private\n */\nexport function dispatchRouteChanged(path) {\n    // Triggering the page model manager to load a new child page model\n    // No need to use a cache as the PageModelManager already does it\n    ModelManagerSerice.getData({path: path}).then(function (model) {\n        PathUtils.dispatchGlobalCustomEvent(EventType.PAGE_MODEL_ROUTE_CHANGED, {\n            detail: {\n                model: model\n            }\n        });\n    });\n}\n\n/**\n * Triggers the PageModelManager to fetch data based on the current route\n *\n * @fires cq-pagemodel-route-changed - with the root page model object\n *\n * @param {string} [url]    - url from which to extract the model path\n *\n * @private\n */\nexport function routeModel(url) {\n    if (!isModelRouterEnabled()) {\n        return;\n    }\n\n    const path = getModelPath(url);\n\n\n    // don't fetch the model\n    // for the root path\n    // or when the route is excluded\n    if (!path || '/' === path || isRouteExcluded(path)) {\n        return;\n    }\n\n    dispatchRouteChanged(path);\n}\n\n// Activate the model router\nif (isModelRouterEnabled()) {\n    // Encapsulate the history.pushState and history.replaceState functions to prefetch the page model for the current route\n    const pushState = window.history.pushState;\n    const replaceState = window.history.replaceState;\n\n    window.history.pushState = function(state, title, url) {\n        routeModel(url);\n\n        return pushState.apply(history, arguments);\n    };\n\n    window.history.replaceState = function(state, title, url) {\n        routeModel(url);\n\n        return replaceState.apply(history, arguments);\n    };\n}\n"],"sourceRoot":""}